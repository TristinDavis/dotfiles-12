#!/usr/bin/env sh
# A reverse proxy that pipes the HTTP response through a shell command
#
# Note, the command given cannot perform input buffering.
# That can be selectively disabled with the stdbuf program from coreutils.
# E.g.: stdbuf -oL -eL tr '[:lower:]' '[:upper:]'

export NAME=$(basename "$0")
export VERSION='0.0.1'
export VERBOSE="${REVPROXY_VERBOSE:-0}"
TEMP_DIR="${TMPDIR-/tmp}/${NAME}.${$}.$(awk \
    'BEGIN {srand(); printf "%d\n", rand() * 10^10}')"

export LERR=2
export LINFO=4; exec 4>/dev/null
export LDEBUG=5; exec 5>/dev/null

LPORT="8081"
RHOST="example.com"
RPORT="80"

toupper_tr () {
    # ${NAME} serve toupper_tr

    socat -v STDIO "TCP:${RHOST}:${RPORT}" \
        | stdbuf -oL -eL tr '[:lower:]' '[:upper:]'
}

toupper_awk () {
    # ${NAME} serve toupper_awk

    socat -v STDIO "TCP:${RHOST}:${RPORT}" \
        | awk '{ print toupper($0); system("") }'
}

script_request () {
    # Usage:
    #
    #     ${NAME} serve script_request ./change_host
    #
    # Where change_host looks like:
    # ```
    # #!/usr/bin/env sh
    # stdbuf -oL -eL sed -e 's/Host:.*/Host: example.com/'
    # ```

    "$@" | socat -v STDIO "TCP:${RHOST}:${RPORT}"
}

script_response () {
    # Usage:
    #
    #     ${NAME} serve script_response ./add_headers
    #
    # Where add_headers looks like:
    # ```
    # #!/usr/bin/env sh
    # stdbuf -oL -eL awk '
    #     NR == 1 { print $0; print "X-Foo: Foo" }
    #     { print $0 }
    # '
    # ```

    socat -v STDIO "TCP:${RHOST}:${RPORT}" | "$@"
}

logging () {
    # Request/response logging
    #
    # Usage:
    #
    #     ${NAME} serve logging

    socat -v STDIO "TCP:${RHOST}:${RPORT}"
}

serve () {
    # ${NAME} serve <command> [...<arg>]

    cmd="${1:?'Missing command to bind.'}"; shift 1
    socat TCP-L:8080,fork,reuseaddr EXEC:"${0} ${cmd} ${@}"
}

help () {
    # Extract contiguous lines of comments and function params as help text
    #
    # Exported environment variables can be used for string interpolation in
    # the extracted commented text.
    #
    local cmd="${1:?'Command name required.'}"

    awk -v cmd="$cmd" '
    $0 ~ "^" cmd "\\s*\\(\\)\\s*{" { is_found=1; next }
    ! is_found { next }
    !NF { exit }
    {
        line=$0
        while(match(line, "[$]{[^}:]*}")) {
            var=substr(line, RSTART+2, RLENGTH -3)
            gsub("[$]{"var"}", ENVIRON[var], line)
        }
        gsub(/^\s*#\s?/, "", line)
        print line
    }
    ' "$0"
}

_all_funcs () {
    # List all public function names in the current file

    awk '$1 !~ /^_/ && /^[a-zA-Z0-9_]+\s*\(\)/ { print $1 }' "$0"
}

_main () {
    # ## Usage
    #
    # `${NAME} [<flags>] (command [<arg>, <name=value>...])`
    #
    #     ${NAME} -h              # Short, usage help text.
    #     ${NAME} help            # All help text. Warning: long!
    #     ${NAME} help command    # Command-specific help text.
    #     ${NAME} command         # Run a command without and with args:
    #     ${NAME} command foo bar baz=Baz qux='Qux arg here'
    #
    # Flag | Description
    # ---- | -----------
    # -V   | Show version.
    # -h   | Show this screen.
    # -v   | Logging output; specify multiple times: info, debug.
    # -x   | Enable xtrace debug logging.
    #
    # Flags _must_ be the first argument to `${NAME}`, before `command`.

    trap '
        excode=$?; trap - EXIT;
        exec 4>&-
        exec 5>&-
        exec 6>&-
        rm -rf '"$TEMP_DIR"'
        exit $excode
    ' INT TERM EXIT

    while getopts Vhvxl:h:p: opt; do
        case $opt in
        V) printf 'Version: %s\n' $VERSION
           exit;;
        h) help _main
           printf '\nAvailable commands:\n\n'
           _all_funcs
           printf '\n'
           exit;;
        v) VERBOSE=$(( VERBOSE + 1 ));;
        x) set -x;;
        l) LPORT="$OPTARG";;
        h) RHOST="$OPTARG";;
        p) RPORT="$OPTARG";;
        esac
    done
    shift $(( OPTIND - 1 ))

    # Selectively enable logging.
    [ $VERBOSE -gt 0 ] && exec 4>&2
    [ $VERBOSE -gt 1 ] && exec 5>&2

    mkdir -p -m 700 "$TEMP_DIR"

    cmd="${1:?"No command given. Available commands: $(_all_funcs | sort)"}"
    shift
    printf 'Running command %s\n' "$cmd" 1>&$LDEBUG
    "$cmd" "$@"
    ret=$?

    exit $ret
}

_main "$@"
